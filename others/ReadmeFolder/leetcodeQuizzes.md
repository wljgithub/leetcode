## 链表




## 位运算

位运算就是对二进制位的数进行操作，比如与或非运算，左移右移等

| 运算类型 |   描述   |  运算符(golang) |                                                            使用场景                                                            |
|----------|----------|---|--------------------------------------------------------------------------------------------------------------------------------|
| and      | 与运算   |  & | 一般用于取位操作，比如根据第一位来判断奇数还是偶数： x&1，如果值为1则为奇数                                                    |
| or       | 或运算   |  I | 用于强制赋值，比如改变第一位，将奇数变为偶数:x=x                                                                               |
| xor      | 异或运算 |  a^b | 异或运算用于第k为取反，或判断一个数在数组中出现奇偶次(异或符合交换律，且a^a=0)                                                 |
| not      | 非运算   |  ^a | 如果对无符号数进行非运算，即为与上界的差，比如 var u uint8 = 1,非运算后就为：254(255-1)，如果是有符号数，则为补码，即取反后加1 |
| shl      | 左移     |<<                                                                                                                                 |左移一位，相当于乘2
| shir     | 右移     |  >> |右移一位，相当于除2                                                                                                                                |




A1:为什么int8的取值范围是 -128~127，而不是 -127~127
	
	对于有符号的数来说，最高位为符号位，按理来说取值是 -127~127。 但是多了一位 10000000,-1后01111111 -->取反10000000
	
##### 统计两个数的二进制表示有多少位不同
[461.汉明距离 (Esay)](https://leetcode-cn.com/problems/hamming-distance/)
```
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 231.

示例:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

```
进行异或操作，然后统计有二进制位有多少个不同的1
```go
func hammingDistance(x int, y int) int {
    temp:=x^y
    count:=0
    for temp!=0{
        count++
        temp=temp&(temp-1)  //一个小技巧，每执行一次这种操作，就消掉一个最右边的1
    }
    return count
}
```

##### 只出现一次的数字

[136.只出现一次的数字 (Esay)
](https://leetcode-cn.com/problems/single-number/)

```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
```
直接遍历数组，对每个数进行异或就好，因为a^a=0,所以出现偶数次的数都会给约掉，且异或运算满足交换律，异或的时候[A,B,C,B,A] =[A,A,B,B,C]
```go
func singleNumber(nums []int) int {
    var once int
    for _,v:=range nums{
        once^=v
    }
    return once
}
```